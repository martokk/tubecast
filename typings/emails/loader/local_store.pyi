"""
This type stub file was generated by pyright.
"""

class FileNotFound(Exception):
    ...


def split_template_path(template): # -> list[Unknown]:
    """Split a path into segments and perform a sanity check.  If it detects
    '..' in the path it will raise a `TemplateNotFound` error.
    """
    ...

def open_if_exists(filename, mode=...): # -> IO[Any] | None:
    """Returns a file descriptor for the filename if that file exists,
    otherwise `None`.
    """
    ...

class BaseLoader:
    def __getitem__(self, filename): # -> None:
        ...

    def get_file(self, name):
        ...

    def list_files(self):
        ...

    def content(self, filename, is_html=..., decode=..., guess_charset=..., charset=...): # -> str | bytes | None:
        ...

    def find_index_file(self, filename=..., extensions=..., stop_names=..., raise_if_not_found=...): # -> None:
        ...

    def find_index_html(self, filename=...): # -> None:
        ...

    def find_index_text(self, filename=...): # -> None:
        ...



class FileSystemLoader(BaseLoader):
    """Loads templates from the file system.  This loader can find templates
    in folders on the file system and is the preferred way to load them.

    The loader takes the path to the templates as string, or if multiple
    locations are wanted a list of them which is then looked up in the
    given order:

    >>> loader = FileSystemLoader('/path/to/templates')
    >>> loader = FileSystemLoader(['/path/to/templates', '/other/path'])

    Per default the template encoding is ``'utf-8'`` which can be changed
    by setting the `encoding` parameter to something else.
    """
    def __init__(self, searchpath, encoding=..., base_path=...) -> None:
        ...

    def get_file(self, filename): # -> tuple[Any, str]:
        ...

    def list_files(self): # -> Generator[str, None, None]:
        ...



class ZipLoader(BaseLoader):
    """
    Load files from zip file
    """
    common_filename_charsets = ...
    def __init__(self, file, encoding=..., base_path=...) -> None:
        ...

    def get_file(self, name): # -> tuple[bytes, str | Unknown | <subclass of LiteralString and bytes>]:
        ...

    def list_files(self): # -> list[Unknown]:
        ...



class MsgLoader(BaseLoader):
    """
    Load files from email.Message
    """
    common_charsets = ...
    def __init__(self, msg, base_path=...) -> None:
        ...

    def decode_text(self, text, charset=...): # -> tuple[Unknown, Unknown] | tuple[Unknown, str] | tuple[Unknown, None]:
        ...

    def clean_content_id(self, content_id):
        ...

    def extract_part_text(self, part):
        ...

    def add_html_part(self, part): # -> None:
        ...

    def add_text_part(self, part): # -> None:
        ...

    def add_attachment_part(self, part): # -> None:
        ...

    def parse(self): # -> None:
        ...

    def get_file(self, name): # -> tuple[Unknown, Unknown | None]:
        ...

    def list_files(self): # -> dict[Unknown, Unknown]:
        ...

    @property
    def attachments(self): # -> dict_values[Unknown, Unknown]:
        ...

    @property
    def html(self): # -> list[Unknown] | None:
        ...

    @property
    def text(self): # -> list[Unknown] | None:
        ...

    def decode_header_value(self, v):
        ...

    def decode_address_header_value(self, value, skip_invalid=...): # -> list[Unknown]:
        ...

    def filter_header(self, name): # -> bool:
        ...

    def copy_header_to_message(self, message, name, value): # -> None:
        """
        Set header in email.Message

        :param message: message to set header to
        :param name: header name
        :param value: header value
        :return:
        """
        ...

    def copy_headers_to_message(self, message): # -> None:
        """
        Decode headers from loaded email.Message object and copy them to emails.Message object

        :param message: emails.Message object to copy headers to
        :param headers: list of headers to parse. if None, parse 'Subject' header and all 'address headers'
        :return: None
        """
        ...
